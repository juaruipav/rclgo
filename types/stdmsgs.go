package types

// #cgo CFLAGS: -I/opt/ros/crystal/include
// #cgo LDFLAGS: -L /opt/ros/crystal/lib -lrcl -lrosidl_generator_c -lrosidl_typesupport_c -lstd_msgs__rosidl_generator_c -lstd_msgs__rosidl_typesupport_c
// #include <rosidl_generator_c/message_type_support_struct.h>
// #include <rosidl_generator_c/string_functions.h>
// #include <std_msgs/msg/string.h>
// #include <std_msgs/msg/int64.h>
//const rosidl_message_type_support_t* get_typesupport_std_msgs_msg_string(){
//     return ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
//}
//const rosidl_message_type_support_t* get_typesupport_std_msgs_msg_int64(){
//     return ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int64);
//}
import "C"
import (
	"fmt"
	"reflect"
	"unsafe"
)

// FIX ME: For each datatype in RCL, there must be an equivelent function like
// these on the CGO header, this is mainly because there is no way to access
// RCL MACRO Functions without methion them inside other functions.
// Also these Handler files can be autogenerated, but that feature is not even
// planned at the time of this writing.
//
// ##########################################################################
// #		FUTURE CGO IMPLEMENTATION CODE Examples
// ##########################################################################
//const rosidl_message_type_support_t* get_typesupport_std_msgs_msg_uint64(){
//     return ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Uint64);
//}
//const rosidl_message_type_support_t* get_typesupport_std_msgs_msg_float(){
//     return ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Uint64);
//}
//const rosidl_message_type_support_t* get_typesupport_std_msgs_msg_bytes(){
//     return ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Uint64);
//}

// StdmsgsSupport Support structure for std_msgs/msg/*
type StdmsgsSupport struct {
	typeSupport *C.rosidl_message_type_support_t
}

type typesupportMetadata struct {
	sizeOf   uint64
	isDirect bool
}

// Automatic initialization method
// Registers this typesupport handler to the handler manager
func init() {

	// Variable declaration
	var supportManager TypesupportManagerInterface

	// Variable instantiation
	supportManager = GetTypesupportHandler()

	// Register handler on the manager
	supportManager.setHandler("stdmsgs", StdmsgsSupport{})
}

// GetROSTypesupportPointer Given a stdmsgs datatype structure, returns it's respective C pointer to initialize
// the subscriber or publisher.
func (support StdmsgsSupport) GetROSTypesupportPointer(msg MSGInterface) (*C.rosidl_message_type_support_t, error) {

	// Variable declaration
	var msgReflection reflect.Type
	var msgStructName string
	var err error

	// Create new reflect.Type structure
	msgReflection = reflect.TypeOf(msg)
	//fmt.Printf("reflect.Type: %+v\n", msgReflection)

	// Get msg structure name and sanitize it
	msgStructName = msgReflection.String()
	msgStructName = sanitizeKey(msgStructName)

	// switch through all the distinct cases
	// TODO: Add missing datatypes
	switch msgStructName {
	case "stdmsgs.String":
		support.typeSupport = C.get_typesupport_std_msgs_msg_string()
	case "stdmsgs.Int64":
		support.typeSupport = C.get_typesupport_std_msgs_msg_int64()
	default:
		support.typeSupport = nil
		err = fmt.Errorf("datatype \"%s\" is unknown to TypesupportHandler \"%s\"", msgStructName, "stdmsgs")
	}

	return support.typeSupport, err
}

// ParseCTypesupport Given a stdmsgs datatype and a C typesupport structures,
// it will copy the C contents to the stdmsgs structure.
func (support StdmsgsSupport) ParseCTypesupport(msg MSGInterface, typesupport CTypesupport) error {

	// Variable declaration
	var metadata typesupportMetadata
	var data []byte
	var err error

	// leave if empty message
	if typesupport.typesupport_identifier == nil {
		return nil
	}

	// Load typesupport's metadata required to interpret the datatype struct
	metadata, err = support.getTypesupportMetadata(msg)
	if err != nil {
		return err
	}

	// Check for Object Pointer and obtain the respective bytes
	if metadata.isDirect {
		cBytesPointer := (*C.char)(unsafe.Pointer(&typesupport.typesupport_identifier))
		data = C.GoBytes(unsafe.Pointer(cBytesPointer), C.int(metadata.sizeOf))
	} else {
		size := uint64(C.ulong(*(*C.ulong)(unsafe.Pointer(&typesupport.data))))
		data = C.GoBytes(unsafe.Pointer(typesupport.typesupport_identifier), C.int(size))
	}

	// Assing data to the Golang object
	err = msg.ParseBytes(data)

	return err
}

// GetCTypesupport Given a stdmsgs datatype converts it's content into an equivelent
// C structure to be sended through RCL.Publish method.
func (support StdmsgsSupport) GetCTypesupport(msg MSGInterface) (unsafe.Pointer, error) {

	// Variable declaration
	var msgC unsafe.Pointer
	var msgReflection reflect.Type
	var msgStructName string
	var err error
	var castedValue reflect.Value

	// Create new reflect.Type structure
	msgReflection = reflect.TypeOf(msg)

	// Get msg structure name and sanitize it
	msgStructName = msgReflection.String()
	msgStructName = sanitizeKey(msgStructName)

	// switch through all the distinct cases
	// TODO: Add missing datatypes
	switch msgStructName {
	case "stdmsgs.String":

		// Equivelent C datatype structure
		msgCTemp := C.struct_std_msgs__msg__String{}

		// Reflected data field from msg
		castedValue = support.getCastedValue(msg)

		// Obtain string text from reflected struct
		msgString := castedValue.String()

		// cast to respective C datatype (int64 -> char array)
		cText := C.CString(msgString)

		// In the case of Strings, ROS has it's own set of methods to define de correct fields
		C.rosidl_generator_c__String__assign(&msgCTemp.data, cText)

		// Cast to C void pointer
		msgC = unsafe.Pointer(&msgCTemp)
	case "stdmsgs.Int64":

		// Equivelent C datatype structure
		msgCTemp := C.struct_std_msgs__msg__Int64{}

		// Reflected data field from msg
		castedValue = support.getCastedValue(msg)

		// Obtain int64 from reflected struct
		msgInt64 := castedValue.Int()

		// cast to respective C datatype (int64 -> long)
		cLong := C.long(msgInt64)

		// Assing to the respective value in C datatype
		msgCTemp.data = cLong

		// Cast to C void pointer
		msgC = unsafe.Pointer(&msgCTemp)
	default:
		support.typeSupport = nil
		err = fmt.Errorf("datatype \"%s\" is unknown to TypesupportHandler \"%s\"", msgStructName, "stdmsgs")
	}

	return msgC, err
}

// getTypesupportMetadata Simplifies the way datatype's metadata is obtained
func (support StdmsgsSupport) getTypesupportMetadata(msg MSGInterface) (typesupportMetadata, error) {

	// Variable declaration
	var msgReflection reflect.Type
	var msgStructName string
	var err error
	var metadata typesupportMetadata

	// Create new reflect.Type structure
	msgReflection = reflect.TypeOf(msg)
	//fmt.Printf("reflect.Type: %+v\n", msgReflection)

	// Get msg structure name and sanitize it
	msgStructName = msgReflection.String()
	msgStructName = sanitizeKey(msgStructName)

	// switch through all the distinct cases
	// TODO: Add missing datatypes
	switch msgStructName {
	case "stdmsgs.String":
		metadata.sizeOf = 0
		metadata.isDirect = false
	case "stdmsgs.Int64":
		metadata.sizeOf = uint64(C.sizeof_struct_std_msgs__msg__Int64)
		metadata.isDirect = true
	default:
		err = fmt.Errorf("datatype \"%s\" is unknown to TypesupportHandler \"%s\"", msgStructName, "stdmsgs")
	}

	return metadata, err
}

// getCastedValue Simplifies the way reflection is used to obtain it's data field
func (support StdmsgsSupport) getCastedValue(msg MSGInterface) reflect.Value {

	// Variable declaration
	var envelopValueOf reflect.Value
	var msgTypeOf reflect.Type
	var dataValue reflect.Value
	var msgIsPointer bool

	// Get TypeOf of msg struct
	msgTypeOf = reflect.TypeOf(msg)

	// Get ValueOf of envelop struct
	envelopValueOf = reflect.ValueOf(msg)

	// Evaluate if msg is a pointer or not
	msgIsPointer = (reflect.Ptr == msgTypeOf.Kind())

	// Detect if it's a pointer or not
	// If it's a pointer there is an aditional step to access fields
	if msgIsPointer {
		envelopValueOf = reflect.Indirect(envelopValueOf)
	}

	// Obtain the dataValue in the case of stdmsgs it's always th same
	dataValue = envelopValueOf.Field(0)

	return dataValue
}
